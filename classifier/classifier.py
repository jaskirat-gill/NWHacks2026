import torch
from transformers import AutoImageProcessor, AutoModelForImageClassification
from PIL import Image
import io
from typing import Dict, Any

MODEL_ID = "Organika/sdxl-detector"

class Classifier:
    """
    SDXL-focused AI aesthetic similarity detector.
    
    IMPORTANT: This model outputs "AI aesthetic similarity score", not AI origin proof.
    The score indicates whether content looks like it was generated by diffusion models,
    but this is NOT a definitive determination of whether the image was AI-generated.
    """
    
    def __init__(self, device=None):
        self.device = device or (torch.device("cuda") if torch.cuda.is_available() else torch.device("cpu"))
        print(f"Loading {MODEL_ID} on {self.device}")
        
        self.processor = AutoImageProcessor.from_pretrained(MODEL_ID)
        self.model = AutoModelForImageClassification.from_pretrained(MODEL_ID)
        self.model.to(self.device)
        self.model.eval()
        
        print(f"Model loaded successfully")
        print(f"Labels: {self.model.config.id2label}")
    
    def predict(self, image_bytes: bytes) -> Dict[str, Any]:
        """
        Calculate AI aesthetic similarity score (not origin proof).
        
        The SDXL model is reinterpreted as providing an "aesthetic similarity score"
        that indicates how much the content resembles diffusion-generated imagery.
        This does NOT prove the image was AI-generated.
        
        Args:
            image_bytes: Raw image bytes
            
        Returns:
            Dictionary with:
                - label: str (original model label for backwards compatibility)
                - confidence: float (original model confidence)
                - aesthetic_similarity_score: float (0-1) - similarity to AI-generated aesthetics
                - scores: Dict with full score distribution
        """
        # Load and convert image
        image = Image.open(io.BytesIO(image_bytes)).convert("RGB")
        
        # Preprocess
        inputs = self.processor(images=image, return_tensors="pt").to(self.device)
        
        # Inference
        with torch.no_grad():
            outputs = self.model(**inputs)
            logits = outputs.logits
            probs = torch.softmax(logits, dim=-1)[0]
        
        # Get prediction
        predicted_idx = logits.argmax(-1).item()
        label = self.model.config.id2label[predicted_idx]
        confidence = probs[predicted_idx].item()
        
        # Extract aesthetic similarity score
        # If model labels AI as positive class, use that probability
        # Otherwise, invert it
        id2label = self.model.config.id2label
        # Find which label corresponds to AI
        ai_label_idx = None
        for idx, lbl in id2label.items():
            if "ai" in lbl.lower() or "artificial" in lbl.lower():
                ai_label_idx = idx
                break
        
        if ai_label_idx is not None:
            aesthetic_similarity_score = float(probs[ai_label_idx].item())
        else:
            # Fallback: use confidence if label suggests AI, otherwise 1 - confidence
            if "ai" in label.lower() or "artificial" in label.lower():
                aesthetic_similarity_score = confidence
            else:
                aesthetic_similarity_score = 1.0 - confidence
        
        # Full distribution
        distribution = {
            id2label[i]: float(probs[i].item())
            for i in range(len(probs))
        }
        
        return {
            "label": label,
            "confidence": confidence,
            "aesthetic_similarity_score": aesthetic_similarity_score,
            "scores": distribution
        }

# Usage example
if __name__ == "__main__":
    classifier = Classifier()
    
    # Test with an image
    with open("test_image.jpg", "rb") as f:
        result = classifier.predict(f.read())
    
    print(f"Prediction: {result['label']}")
    print(f"Confidence: {result['confidence']:.2%}")
    print(f"All scores: {result['scores']}")